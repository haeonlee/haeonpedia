> fastcampus 강의 <파이썬 웹 개발 올인원 패키지 Online.>에서 '파이썬 기초 핵심 과정' 파트를 듣고 정리한 내용입니다.

- 2021/12/02: python-자료구조에서 <06. 링크드 리스트> 공부하다가 클래스 개념이 헷갈려서 notion에 정리해 뒀던 것을 긁어 업로드한다. 올해 1월에 공부한 내용인데, 다시 보니까 가물가물하다. 인스턴스 메소드, 스태틱 메소드, 클래스 메소드 각각 차이를 확실히 공부하고 깔끔하게 정리해 둬야 되겠다.

# 클래스

## 클래스 선언

- 함수는 클래스와 관련 있는 것으로 만들 것
```python
class 클래스명:
	함수
	함수
	함수
```

- pass라고 적어놓으면, 일단 클래스명만 만들고 실행시켜도 에러가 나지 않음
```python
class 클래스명:
	pass
```

---

## 속성과 메소드

- 클래스 내에서 구현해야 할 건, 속성과 메소드
    - 속성: 움직임이 없음 (e.g. 볼펜 제조사, 볼펜 제조 일자)
    - 메소드: 움직임이 있음 (e.g. 볼펜을 누르면 볼펜 심이 들어가고, 볼펜 심이 나오고.)

```python

class UserInfo: # 클래스 네임은 단어별로 대문자로 시작
	def __init__(self, name, phone): #클래스 초기화
		self.name = name
		self.phone = phone

	def user_info_p(self):
		print("Name : ", self.name)
		print("Phone : ", self.phone)

user1 = UserInfo("이말랑", "010-1234-5678") 
# __init__ 를 통해서 값을 할당

user1.user_info_p() 
# user_info_p를 통해서 값을 출력
"""출력: 
Name : 이말랑
hone : 010-1234-5678
"""

print(user1.name)
# 출력: 이말랑

print(user1.__dict__) 
# 출력: {'name': '이말랑', 'phone': '010-1234-5678'}
```

---

## 클래스와 인스턴스

- 클래스와 인스턴스의 차이
    - 클래스: 객체를 만들어내기 위한 설계도 또는 틀
    - 인스턴스: 설계도를 바탕으로 소프트웨어 세계에서 구현된 실체
        - 즉, 소프트웨어 세계에서 객체를 실체화하면 그것을 인스턴스라고 부른다
        
- 네임스페이스: 객체를 인스턴스화 할 때 저장된 공간
    - e.g. 인스턴스들은 서로 독립적인 공간을 이용해 이름, 번호 등(*위 예시의 경우) 각각 다른 정보를 저장하고 있음

---

## 메소드의 종류
- 인스턴스 메소드:
- 스태틱 메소드:
- 클래스 메소드:

---

## self의 이해
- 

```python
class SelfTest :
	def fuction1() :  # 클래스 메소드
		print('함수 1을 불렀습니다')
	def fuction2(self) :  # 인스턴스 메소드
		print(id(self))
		print('함수 2을 불렀습니다')
 
test = SelfTest() # 인스턴스 생성
test.fuction1() 
# 에러 발생: 함수1은 self 인자가 없기 때문에
SelfTest.fuction1() 
# 출력: '함수 1을 불렀습니다'
# 클래스에서 직접 호출하면 됨: 클래스 메소드

test.fuction2() 
# 출력: 12345678
# 출력: '함수 2을 불렀습니다'

SelfTest.fuction2(test) 
# 출력: '함수 2을 불렀습니다'

print(id(test))
# 출력: 12345678 (*위랑 같다는 것이 핵심)
```

---

- 클래스 변수 VS 인스턴스 변수
    - 클래스 변수: 직접 사용 가능, 객체보다 먼저 생성
    - 인스턴스 변수: 객체마다 별도로 존재
        - 객체마다 저장되는 id가 다름: 즉, 주소값이 다르다는 소리
        - 인스턴스 생성 후 사용
        - e.g. user1과 user2의 인스턴스 변수는 각각 존재한다는 얘기

```python
class WareHouse :
	stock_num = 0 # 창고의 개수
	def __init__(self, name) :
		self.name = name
		WareHouse.stock_num += 1 
	def __del__(self) :
		WareHouse.stock_num -= 1

user1 = WareHouse('죠르디')
user2 = WareHouse('어피치')
user3 = WareHouse('고양이')

print(user1.__dict__)
print(user2.__dict__)
print(user3.__dict__)
# 출력 : {'name': '죠르디'}, {'name': '어피치'}, {'name': '고양이'}

print(WareHouse.__dict__) 
# 클래스 네임스페이스, 클래스 변수는 공유
# 출력: {'__module__': '__main__', 'stock_num': 3, ... }

print(user1.stock_num)
# 클래스 변수는 공유하기 때문에: 본인 네임스페이스에 없다면, 클래스 네임스페이스에서 찾아서 사용
# 인스턴스로도 접근 가능
```

- 클래스 상속
    - super class: 부모
    - sub class: 자식 — 상속 받았기 때문에, 부모의 모든 속성과 메소드를 사용 가능
    - 왜 상속을 해야 하는가?
        - 코드의 생산성과 유지 보수: 재사용할 수 있기 때문에
    - e.g. 라면
        - 라면의 속성: 종류, 회사, 맛, 면 종류, 이름 — 부모 클래스
        - 위 부분을 공유한 뒤, 다른 부분을 자식 클래스에서 구현해서 다루면 됨

```python
class Car:
	"""Parent Class"""
	def __init__(self, tp, color):
		self.type = tp
		self.color = color

	def show(self) :
		return 'Car Class "Show Method!"'

class BmwCar(Car) : #class Car를 상속 받음
	"""Sub Class"""
	def __init__(self, car_name, tp, color):
		super().__init__(tp, color)
		self.car_name = car_name
	
	def show_model(self) -> None:
		return "Your Car Name : %s" % self.car_name

class BenzCar(Car) : #class Car를 상속 받음
	"""Sub Class"""
	def __init__(self, car_name, tp, color):
		super().__init__(tp, color)
		self.car_name = car_name
	
	def show_model(self) -> None:
		return "Your Car Name : %s" % self.car_name

	def show(self) : # Super class에 있는 메소드를 Sub class에도 만듦
		return 'Car Info : %s %s %s' %(self.car_name, self.type, self.color)

	def supershow(self) :
		print(super().show()) # Parent Method Call

# 일반 사용
model1 = BmwCar('520d', 'sedan', 'red')

print(model1.color) # super class
print(model1.type) # super class
print(model1.car_name) # sub class
print(model1.show()) # super class: 자식 클래스엔 없지만, 부모 클래스에서 찾아서 출력
print(model1.show_model()) # sub class
print(model1.__dict__)
# 출력: {'type': 'sedan', 'color': 'red', 'car_name': '520d'}

# Method Overriding
model2 = BenzCar("220d", 'suv', "black")
print(model2.show())
# 출력: Car Info : 220d suv black
# sub class의 메소드를 출력: 따라서, super class의 메소드 위로 overriding해서 사용

# Parent Method Call
model3 = BenzCar("350s", "sedan", "silver")
print(model3.supershow())

# Inheritance Info: 상속 정보를 list 형태로 반환
print(BmwCar.mro())
# 출력: [<class '__main__.BmwCar'>, <class '__main__.Car'>, <class 'object'>]
# 좌부터 우로: 상속 관계
```

---

## 클래스 다중 상속

- 단, 상속이 너무 많아진다면 복잡해질 수 있으므로 적절한 사용이 필요

```python
class X():
	pass

class Y():
	pass

class Z():
	pass

class A(X, Y):
	pass

class B(Y, Z):
	pass

class M(B, A, Z):
	pass

print(M.mro())
# 다중 상속도 가능하다는 것을 개념적으로 이해 가능
```