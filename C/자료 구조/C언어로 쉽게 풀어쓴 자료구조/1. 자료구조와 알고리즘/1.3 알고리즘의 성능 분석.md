# 1.3 알고리즘의 성능 분석

## 효율적인 알고리즘이란?

효율적인 알고리즘이란 알고리즘이 시작하여 결과가 나올 때까지 수행시간이 짧으면서 컴퓨터 내 메모리와 같은 자원을 덜 사용하는 알고리즘입니다.

## 프로그래밍 효율성이 중요한 이유

1. 최근 상용 프로그램의 규모가 이전에 비해 커졌습니다
    - 즉, 처리해야 할 자료의 양이 많아졌기 때문에 알고리즘의 효율성이 더욱 중요합니다. 입력 자료의 양이 많아지게 되면 효율성이 높은 프로그램과 낮은 프로그램 간 차이는 상당할 수 있습니다.

    입력 자료의 개수    프로그램 A: n^2     프로그램 B: 2^n
    n=6             36초                64초
    n=100           10000초             4 * 10^22년

2. 사용자들은 여전히 빠른 프로그램을 선호합니다.


## 수행 시간 측정 방법: 프로그램의 효율성을 어떻게 측정할 수 있을까?

알고리즘을 프로그래밍 언어로 작성하여 실제 컴퓨터에서 실행한 다음, 그 수행시간을 측정하는 것이 단순하지만 가장 확실한 방법입니다.

### C언어에서 수행 시간을 측정하는 방법

방법 #1.
```c

#include <time.h>

start = clock();
...
stop = clock();
double duration - (double)(stop - start) / CLOCKS_PRE_SEC;

// clock() 함수는 호출 프로세스에 의하여 사용된 CPU 시간을 계산
// clock() 함수는 호출됐을 때 시스템 시각을 CLOCKS_PER_SEC 단위로 반환
// 초 단위의 시간을 측정하기 위해 (stop-start) 값을 CLOCKS_PER_SEC로 나눔

``` 

방법 #2.
```c

#include <time.h>

start = time(NULL);
...
stop = time(NULL);

double duration = (double) difftime(stop, start);

// time() 함수는 초 단위로 측정된 시간을 반환
// time(NULL) 형태로 호출하면 현재 시간 반환
// difftime()으로 보내면 차이가 초 단위로 반환
```

### 프로그램 1.2 cal_time.c

```c

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void)
{
    clock_t start, stop;
    double duration;
    start = clock();    // 측정 시작
    for (int i=0 ; i < 1000000; i++)    // 의미 없는 반복 루프
        ;
    stop = clock();     // 측정 종료
    duration = (double)(stop - start) / CLOCKS_PER_SEC;
    printf("수행 시간은 %f초입니다.\n", duration);
    return 0;
}

/* 실행 결과
수행 시간은 0.001804초입니다.
*/

```

<b>수행 시간 계산 프로그램을 구동하는 것에 대한 문제점</b>

1. 알고리즘을 구현하고 테스트하는 것이 필요합니다. 알고리즘이 복잡한 경우엔, 구현해야 한다는 점이 큰 부담이 될 수 있습니다.
2. 사용한 하드웨어 환경이 동일해야 합니다. 
3. 사용한 소프트웨어 환경이 동일해야 합니다: 프로그래밍에 사용한 컴퓨터 언어에 따라 수행 속도가 달라질 수 있습니다.
    - C언어와 같은 컴파일 언어를 사용한 경우가 베이직과 같은 인터프리터 언어를 사용한 경우보다 빠른 수행을 보입니다.
4. 실험되지 않은 입력에 대해서는 수행시간을 주장할 수 없습니다: 실험에 사용했던 데이터가 아닌 다른 데이터에 대해서는 전혀 다른 결과가 나올 수 있습니다.


## 알고리즘 복잡도 분석(Algorithm complexity analysis) 방법

알고리즘 복잡도 분석은 구현하지 않고도 모든 입력을 고려하는 방법이며, 실행 하드웨어나 소프트웨어 환경과는 관계없이 알고리즘의 효율성을 평가할 수 있습니다.

### 알고리즘 분석에서 '좋다'의 의미

알고리즘 분석에서는 두 가지 측면을 고려할 수 있습니다. 

1. 시간 복잡도(time complexity): 알고리즘의 수행 시간 분석
2. 공간 복잡도(space complexity): 알고리즘이 필요로 하는 기억 공간의 양

우리가 알고리즘의 복잡도를 얘기할 땐 대개 시간 복잡도를 말합니다. 이유는 대개 알고리즘이 차지하는 공간보단 수행시간에 더 관심이 있기 때문입니다.

### 시간 복잡도(time complexity) 함수

시간 복잡도는 알고리즘의 절대적인 수행 시간을 나타내는 것이 아니라, 알고리즘을 이루고 있는 연산들이 몇 번 수행되는지 숫자로 표현합니다. 즉, 어떤 알고리즘이 수행하는 연산의 개수를 계산하여 두 알고리즘을 비교하는 것입니다.
- 연산의 종류: 덧셈, 곱셈과 같은 산술 연산, 대입 연산, 비교 연산, 이동 연산 등

이때 연산들의 수행횟수는 프로그램에 주어지는 입력의 개수 n에 따라 변하게 됩니다. 따라서 일반적으로 연산의 수행횟수는 고정된 숫자가 아니라, n에 대한 함수가 됩니다.

### 시간 복잡도 함수
연산의 수를 입력의 개수 n의 함수로 나타낸 것을 시간 복잡도 함수라고 하고, T(n)으로 표기합니다.

<b>양의 정수를 n을 n번 더하는 문제</b>

![Algorithm ABC](https://user-images.githubusercontent.com/76417259/185064818-c171177e-0122-457f-b70c-59a74aeab427.jpeg)

- 알고리즘 A: 간단하게 n*n을 계산
- 알고리즘 B: n을 n번 더함, 즉 n+n+...+n을 반복하는 셈
- 알고리즘 C: 1을 n*n번 더함

![표 1-3  알고리즘의 비교](https://user-images.githubusercontent.com/76417259/185064843-501b5bc7-99da-4fe6-a087-8029b5433e7c.jpeg)

- 사실 곱셈 연산이 덧셈 연산보다 시간이 더 걸리겠지만, 모든 연산이 동일한 시간이 걸린다고 가정하여 알고리즘을 비교합니다.
- 하나의 연산이 t만큼 시간이 걸린다고 가정하면, 알고리즘 A는 2t에 비례하는 시간이 필요하고, 알고리즘 B는 2nt의 시간이, 알고리즘 C는 2n^2t만큼의 시간이 걸립니다.

![그림 1-9  알고리즘의 시간 복잡도 함수](https://user-images.githubusercontent.com/76417259/185064855-b4e4b15f-d10e-431a-a881-2a3eb5f4606b.jpeg)

- n이 커질수록 알고리즘 간의 차이가 커지는 것을 확인할 수 있습니다.


