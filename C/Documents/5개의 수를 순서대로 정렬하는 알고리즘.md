작성일: 2022. 08. 06

책 <혼자 공부하는 C언어>에서 17장 도전 실전 예제를 풀다가 '5개의 수를 큰 순서대로 정렬하는 알고리즘'을 작성했다. 

그러나
(1) 중첩 for문으로 구성한 기존의 코드가 효율적이지 않다고 판단했고
(2) 심지어 그렇게 작성한 코드도 내 생각과 반대로 실행(내림차순으로 될 줄 알았는데, 오름차순으로 결과가 나옴)됐다.

그리하여
(1) '5개의 수를 순서대로 정렬하는 알고리즘'의 효율적인 코드를 알아보고,
(2) 기존 코드가 왜 내 생각과 반대로 구동됐는지 그 이유를 정리해 보겠다.

# (1) '5개의 수를 순서대로 정렬하는 알고리즘'

### 기존 알고리즘: 비효율적

``` c
for (i=0; i<5; i++)
    {
        for(j=0; j<5; j++)
        {
            if ( lp[i].avg >= lp[j].avg ) 
            {
                temp = lp[i];
                lp[i] = lp[j];
                lp[j] = temp;
            }
        }
    }
```

코드 해석
- lp[i].avg가 lp[j].avg보다 크다면, 두 배열을 바꾸는 코드다.

문제점
- 위 코드는 불필요하게 연산 횟수가 많다. (예를 들어 숫자 1과 3이 있다고 하자. 그럼 1과 3을 한 번만 연산해도 3이 큰 것을 알 수 있는데, 위 함수는 1과 3을 비교한 뒤에 3과 1을 또 비교한다.)
- 더불어 두 수를 비교한 다음에, 두 배열을 바꾸는 것도 너무 많다. 사실상 순서대로 수를 비교하면서 첫 번째 자리엔 avg 멤버 값이 가장 큰 배열 하나만 넣으면 그만인데, 위 코드는 배열을 넣었다 뺐다만 엄청나게 많이 반복한다.

### 수정 알고리즘: 효율적

``` c
for(i = 0; i < 4; i++)
{
    max = i;
    for(j = i + 1; j < 5; j++)
    {
        if(pary[max].tot < pary[j].tot)
        {
                max = j;
        }
    }
    if(max != i)
    {
        temp = pary[max];
        pary[max] = pary[i];
        pary[i] = temp;
    }
}
```

코드 해석
- 기준점을 첫 번째 요소, 두 번째 요소, 세 번째 요소, 네 번째 요소로 바꾸어 가며 비교점을 그 아래 요소들로만 두는 방식이다. (내가 처음 문제를 보고 연상한 방식이다. 머리로는 생각했지만 코드로는 구상하지 못해 위와 같은 코드를 짠 것이다.)
- 그리고 max 값이라는 변수를 추가하여, 기준점 아래의 비교점 중에서 가장 큰 수의 인덱스를 max값에 추가한다.
- 이후 if (max != i)라면 비교점들에서 가장 큰 수의 인덱스를 빌려서 배열을 바꾼다.

해결점
- 불필요할 정도로 많은 비교를 하지도 않고(딱 필요한 만큼만 함)
- 직관적으로 이해하기도 쉬우며
- 배열 자체를 바꾸는 연산은 max값으로 인덱스가 바뀐 뒤에 수행하므로 훨씬 더 프로그램이 가볍다.


# (2) 오름차순과 내림차순

``` c
for (i=0; i<5; i++)
{
    for(j=0; j<5; j++)
    {
        if ( lp[i].avg <= lp[j].avg ) 
        {
            temp = lp[i];
            lp[i] = lp[j];
            lp[j] = temp;
        }
    }
}
```

내 생각과 코드 간의 차이
- 나는 위와 같이 작성하면, 큰 순서대로 배열될 것이라고 생각했다: 기준점이 되는 [i] 값을 비교점이 되는 [j]와 비교해서, [j] 값이 더 크면 [i]랑 바꾸어서 순서대로 착착 큰 순서가 될 줄 알았다.
- 그러나 정작 코드는 반대로 작은 순서대로 배열됐다.

차이가 발생한 원인
- 위 함수는 lp[i].avg(i=0, 1, 2, 3, 4)와 lp[j].avg(i=0, 1, 2, 3, 4)을 비교하는 연산을 계속 반복한다고 봐야 한다. 더불어 비교할 때마다 if문을 충족한다면 avg의 값도 계속해서 바뀐다.
- i=0일 때 위 연산을 수행하면, lp[0].avg 값엔 가장 큰 수가 배열이 되는 것이 맞다.
- 그러나 문제는 lp[1].avg를 다시 lp[0].avg와 비교하게 된다는 것이다. 그러면 lp[0].avg는 lp[1].avg 자리로 옮겨오게 된다.
- 즉, 가장 큰 수는 순서대로 쭉쭉 인덱스 4 자리까지 이동하게 된다. (위 함수가 무척이나 비효율적인 이유다)

오착한 이유
- i=0일 때만, 머릿속으로 생각을 해봤다. 앞으로는 두 번째 루프까지는 머리로 생각을 해 봅시다.