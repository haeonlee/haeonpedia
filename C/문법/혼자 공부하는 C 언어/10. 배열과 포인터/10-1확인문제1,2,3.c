// 10-1. 배열과 포인터의 관계
/* 다음과 같이 배열과 포인터가 초기화되고, 그림처럼 메모리에 할당되었다고 가정합니다. (1번~3번) */

/*
    double ary[5] = {1.2, 3.5, 7.4, 0.5, 10.0}
    double *pa = ary;
    double *pb = ary + 2;

    100 108 116 124 132
    1.2 3.5 7.4 0.5 10.0
*/

/*
    1. 다음 각 항목의 값을 생각해보세요.

    (1) ary = 100
    배열명은 첫 번째 배열 요소 ary[0]의 주소

    (3) pa + 2 = 116
    pa가 100이고, 가리키는 자료형이 double이므로 100 + (2 * sizeof(double))
    
    내 답안
    (1) ary = 1.2
    (2) *(ary + 1) = 3.5
    (3) pa + 2 = 7.4
    (4) pa[3] = 0.5
    (5) *pb = 7.4
    (6) pb - pa = 2
*/

/*
    2. 다음 중 사용법이 맞는 것은 O표, 잘못된 표현은 X표 하세요.

    (1) ary[5] (X): 배열 요소의 수가 5개이므로 첨자는 0~4까지만 사용 가능
    (3) ++(*ary) (O): *ary가 첫 번째 배열 요소이므로 ++(*ary)는 그 값을 증가
    (5) *(pb + 3): 초기화된 pb는 세 번째 배열 요소를 가리키므로 pb + 3은 배열의 할당 영역을 벗어남

    내 답안
    (1) ary[5] (O)
    (2) ary++ (X)
    (3) ++(*ary) (X)
    (4) pb[-2] (O)
    (5) *(pb + 3) (O)
    (6) *(++pa) (O)
*/

/*
    3. 다음은 포인터 pb로 세 번째 배열 요소부터 마지막 배열 요소까지 출력하는 코드입니다.
    빈칸을 채워보세요.

    for (i = 0; i < 3; i++)
    {
        printf("%.1f", *pb);
        pb++;   // 다음 배열 요소로 이동
    }

*/