// 15-4. 주소로 쓰이는 배열명과 배열의 주소 비교

/*

    배열 요소의 주소와 배열의 주소

        지금까지는 배열명을 첫 번째 요소의 주소로 사용해왔습니다.
        이제 배열 전체를 하나의 변수로 생각하고 그 주소를 구해봅시다.

        배열의 주소     int ary[5]
        &ary         int int int int int


    (주소로 쓰이는 ary) vs (배열의 주소 &ary)

        두 값 모두 배열의 시작 위치를 나타내지만,

        가리키는 대상이 다르므로 두 주소에 1을 더한 결과가 다릅니다.
        ary 자체가 주소로 쓰일 땐 첫 번째 요소를 가리키므로 대상의 크기는 4가 됩니다.

        반면에 배열의 주소 &ary(ary에 주소 연산자를 사용)는 배열 전체를 가리키므로
        대상의 크기는 20이 됩니다.


    여기서 잠깐. 배열의 크기와 배열 요소의 개수
        배열의 주소가 가리키는 대상의 크기: 4바이트*(배열 요소의 수) = 20
        
        이 책에서는 배열의 크기를 '메모리에 할당된 크기(전체 바이트 수)'로 정의함.
        일반적으론 배열의 크기라는 말을 일반적으로 요소의 개수(저장 가능한 데이터 수)로 표현하긴 하지만,
        C에서는 배열의 메모리 크기도 알아야 하므로 구분 지어 이해할 것.

    규칙1. 배열은 전체가 하나의 논리적인 변수입니다
        (1) sizeof 연산자 사용: sizeof(ary)
        (2) 주소 연산자 사용: &ary
        단, 배열은 논리적인 변수이므로 일반 변수처럼 대입 연산자에 사용하는 것은 불가능합니다.
        ary 배열의 어떤 요소에 값을 저장할 것인지 알 수 없기 때문입니다.

    규칙2. 배열의 주소에 정수를 더하면 배열 전체 크기를 곱해서 더합니다.

        (1) 배열의 정수 연산: ary + 1 = 주소 값 + (1 * sizeof(ary[0]))
        (2) 배열의 주소에 정수 연산: &ary + 1 = 주소 값 + (1 * sizeof(ary))

        그러나, 배열의 주소에 정수를 더하면 배열이 할당된 메모리 영역을 벗어나므로
        특별한 경우가 아니면 사용하지 않습니다.
        e.g. 배열의 주소는 주로 2차원 이상의 배열에서 사용합니다.
        
*/

#include <stdio.h>

int main(void)
{
    int ary[5];

    printf("    ary의 값 : %u\t", ary);     // 주소로서의 배열명의 값
    printf("ary의 주소 : %u\n", &ary);      // 배열의 주소
    printf("    ary + 1 : %u\t", ary + 1);
    printf("    &ary + 1 : %u\t", &ary + 1);

    return 0;
}

/* 실행 결과

    ary의 값 : 3100851952       ary의 주소 : 3100851952
    ary + 1 : 3100851956            &ary + 1 : 3100851972    

    ary를 사용한 경우는 +4 차이
    &ary를 사용한 경우는 +20 차이  

*/