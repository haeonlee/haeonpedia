// 15-1. 포인터와 이중 포인터의 관계

/*

    이중 포인터: 포인터의 주소 값을 저장
        - 어떤 변수를 가리키는 포인터 pi가 있다고 합시다, 포인터 pi가 할당된 메모리는 주소 200번지에서 시작됩니다
        - 그렇다면 포인터 pi를 가리키는 주소 값은 '200번지'는 어떻게 관리하면 좋을까요?
        - 그 주소 값(&pi)을 저장하는 포인터가 바로 이중 포인터입니다

    이중 포인터 선언
        int **ppi;
        
        (1) 첫 번째 별: ppi가 가리키는 자료형이 포인터임을 뜻함
        (2) 두 번째 별: ppi 자신이 포인터임을 뜻함

    포인터 연산의 비밀
        규칙1. 포인터를 변수명(r-value)로 쓰면 그 안의 값이 됩니다
        규칙2. 포인터에 & 연산을 하면 포인터 변수의 주소가 됩니다
        규칙3. 포인터의 * 연산은 화살표를 따라갑니다
        규칙4. 이중 포인터에 ** 연산을 하면 화살표를 두 번 따라가게 되는 셈입니다

    이중 포인터의 형태
        (1) 포인터(int *형): int형 변수의 주소를 저장하는 포인터
            int a = 10;
            int *pi = &a;
            이때 int는 가리키는 자료형, *는 자신이 포인터임을 뜻함

        (2) 이중 포인터 (int **형): (int *)형 변수의 주소를 저장하는 포인터
            int **ppi;
            이때 int *은 가리키는 자료형, *은 자신이 포인터임을 뜻함
    
    여기서 잠깐. (double *)이나 (double **)형은 왜 4바이트인가요?
        (double *)이나 (double **)형은 4바이트,
        왜냐하면 포인터 앞에 적어주는 double이나 int는 포인터가 가리키는 자료형에 대한 정보일 뿐,
        포인터는 주소 값을 저장하는 변수이므로 주소 값 크기에 따라 포인터 크기가 결정됨

    주소와 포인터의 차이
        포인터는 변수이므로 주소 연산자를 활용하여 주소를 구할 수 있지만,
        주소 상수엔 주소 연산자를 쓸 수 없다

        int a;
        int *pi = &a;   // 주소를 포인터에 저장
        &pi;            // 포인터에 주소 연산자 사용 가능 (O)
        &(&a);          // a의 주소에 다시 주소 연산자 사용 불가능 (X)

    다중 포인터: 이중 이상의 포인터
    
        이중 포인터가 가리키는 자료형이 double 포인터일 때,
        이중 포인터를 가리키는 3중 포인터는 다음과 같이 선언합니다

        double ***ppp;

        같은 방식으로 4중 이상의 포인터도 사용할 수 있으나 프로그램의 가독성을 떨어뜨리므로 가능하면 사용하지 않습니다.

*/

#include <stdio.h>

int main(void)
{
    int a = 10;     // int형 변수의 선언과 초기화
    int *pi;        // 포인터 선언
    int **ppi;      // 이중 포인터 선언
                    // 첫 번째 별: ppi가 가리키는 자료형이 포인터임을 뜻함
                    // 두 번째 별: ppi 자신이 포인터임을 뜻함

    pi = &a;        // int형 변수의 주소를 저장한 포인터
    ppi = &pi;      // 포인터의 주소를 저장한 이중 포인터

    printf("-----\n");
    printf("변수    변숫값  &연산   *연산   **연산\n");
    printf("-----\n");
    printf("    a%10d%10u\n", a, &a);
    printf("    pi%10u%10d\n", pi, &pi, *pi);
    printf("    ppi%10u%10u%10u%10u\n", ppi, &ppi, *ppi, **ppi);
    printf("-----\n");

    return 0;
}


/* 실행 결과

    -------------------------------------------
    변수 변숫값 &연산 *연산 **연산
    -------------------------------------------a 10 00000100
    pi 00000100 00000200 10
    ppi 00000200 00000300 00000100 10
    -------------------------------------------

    실행결과에 보이는 주소 값은 설명의 편의를 위해 수정하였음.

    주소값   300            200         100
    저장값   200(주소값)      100(주소값)   10(숫자)
           이중 포인터 ppi   포인터 pi     변수 a


*/