// 18-6. 파일의 형태와 개방 모드가 다른 경우

/*

    텍스트 파일과 바이너리 파일

        파일은 데이터의 기록 방식에 따라
        텍스트(text) 파일과 바이너리(binary) 파일로 나눕니다.

        (1) 텍스트 파일: 데이터를 아스키 코드 값에 따라 저장
            아스키 코드 값에 따라 데이터를 읽고 저장하는 메모장 같은 프로그램에서 확인 가능
            e.g. txt 파일

        (2) 바이너리 파일: 그 이외의 방식으로 저장
            바이너리 파일은 해당 기록 방식을 적용한 별도의 프로그램을 사용해야 함
            e.g. 그림판 프로그램

        따라서 파일을 개방할 때 개방 모드에 파일의 형태도 함께 표시해야 합니다.


    개방 모드에 파일 형태를 함께 표기하기

        (1) 텍스트 파일: 텍스트 파일은 t를 추가하여 개방합니다

        개방 모드       파일의 용도
        rt          텍스트 파일을 읽기 위해 개방
        wt          텍스트 파일을 쓰기 위해 개방
        at          텍스트 파일의 끝에 추가하기 위해 개방


        (2) 바이너리 파일: 바이너리 파일은 b를 추가하여 개방합니다

        개방 모드       파일의 용도
        rb          텍스트 파일을 읽기 위해 개방
        wb          텍스트 파일을 쓰기 위해 개방
        ab          텍스트 파일의 끝에 추가하기 위해 개방

        파일의 형태를 별도로 표시하지 않으면, 자동으로 텍스트 파일로 개방합니다.

    problem: 파일의 형태와 개방 모드가 다르면, 오류 발생 가능성 up


*/

#include <stdio.h>

int main(void)
{
    FILE *fp;
    int ary[10] = { 13, 10, 13, 13, 10, 26, 13, 10, 13, 10 };
    int i, res;

    fp = fopen("a.txt", "wb");  // 바이너리 파일로 개방
    for (i = 0; i < 10; i++)
    {
        fputc(ary[i], fp);      // 배열 요소의 각 값에 해당하는 아스키 문자 출력
    }
    fclose(fp);

    fp = fopen("a.txt", "rt");  // 같은 파일을 텍스트 파일로 개방
    while (1)
    {
        res = fgetc(fp);        // 파일에서 한 문자 입력
        if (res == EOF) break;
        printf("%4d", res);     // 입력한 문자의 아스키 코드 값 출력
    }
    fclose(fp);

    return 0;
}

/* 실행 결과

  10  13  10


    531p 참고해서 왜 이런 결과가 나왔는지, 이해하세요.

    방식1. fgetc 함수는 리턴 문자(\r)를 읽으면 버리고 다음의 개행 문자(\n) 하나만 입력합니다.
    방식2. fgetc 함수는 ctrl + z에 대한 아스키 문자를 읽으면 파일의 끝으로 인식합니다.

*/