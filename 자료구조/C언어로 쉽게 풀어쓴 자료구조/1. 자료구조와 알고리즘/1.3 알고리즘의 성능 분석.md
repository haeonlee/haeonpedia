# 1.3 알고리즘의 성능 분석

## 효율적인 알고리즘이란?

효율적인 알고리즘이란 알고리즘이 시작하여 결과가 나올 때까지 수행시간이 짧으면서 컴퓨터 내 메모리와 같은 자원을 덜 사용하는 알고리즘입니다.

## 프로그래밍 효율성이 중요한 이유

1. 최근 상용 프로그램의 규모가 이전에 비해 커졌습니다
    - 즉, 처리해야 할 자료의 양이 많아졌기 때문에 알고리즘의 효율성이 더욱 중요합니다. 입력 자료의 양이 많아지게 되면 효율성이 높은 프로그램과 낮은 프로그램 간 차이는 상당할 수 있습니다.

    입력 자료의 개수    프로그램 A: n^2     프로그램 B: 2^n
    n=6             36초                64초
    n=100           10000초             4 * 10^22년

2. 사용자들은 여전히 빠른 프로그램을 선호합니다.


## 수행 시간 측정 방법: 프로그램의 효율성을 어떻게 측정할 수 있을까?

알고리즘을 프로그래밍 언어로 작성하여 실제 컴퓨터에서 실행한 다음, 그 수행시간을 측정하는 것이 단순하지만 가장 확실한 방법입니다.

### C언어에서 수행 시간을 측정하는 방법

방법 #1.
```c

#include <time.h>

start = clock();
...
stop = clock();
double duration - (double)(stop - start) / CLOCKS_PRE_SEC;

// clock() 함수는 호출 프로세스에 의하여 사용된 CPU 시간을 계산
// clock() 함수는 호출됐을 때 시스템 시각을 CLOCKS_PER_SEC 단위로 반환
// 초 단위의 시간을 측정하기 위해 (stop-start) 값을 CLOCKS_PER_SEC로 나눔

``` 

방법 #2.
```c

#include <time.h>

start = time(NULL);
...
stop = time(NULL);

double duration = (double) difftime(stop, start);

// time() 함수는 초 단위로 측정된 시간을 반환
// time(NULL) 형태로 호출하면 현재 시간 반환
// difftime()으로 보내면 차이가 초 단위로 반환
```

### 프로그램 1.2 cal_time.c

```c

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void)
{
    clock_t start, stop;
    double duration;
    start = clock();    // 측정 시작
    for (int i=0 ; i < 1000000; i++)    // 의미 없는 반복 루프
        ;
    stop = clock();     // 측정 종료
    duration = (double)(stop - start) / CLOCKS_PER_SEC;
    printf("수행 시간은 %f초입니다.\n", duration);
    return 0;
}

/* 실행 결과
수행 시간은 0.001804초입니다.
*/

```

<b>수행 시간 계산 프로그램을 구동하는 것에 대한 문제점</b>

1. 알고리즘을 구현하고 테스트하는 것이 필요합니다. 알고리즘이 복잡한 경우엔, 구현해야 한다는 점이 큰 부담이 될 수 있습니다.
2. 사용한 하드웨어 환경이 동일해야 합니다. 
3. 사용한 소프트웨어 환경이 동일해야 합니다: 프로그래밍에 사용한 컴퓨터 언어에 따라 수행 속도가 달라질 수 있습니다.
    - C언어와 같은 컴파일 언어를 사용한 경우가 베이직과 같은 인터프리터 언어를 사용한 경우보다 빠른 수행을 보입니다.
4. 실험되지 않은 입력에 대해서는 수행시간을 주장할 수 없습니다: 실험에 사용했던 데이터가 아닌 다른 데이터에 대해서는 전혀 다른 결과가 나올 수 있습니다.

---

## 알고리즘 복잡도 분석(Algorithm complexity analysis) 방법

알고리즘 복잡도 분석은 구현하지 않고도 모든 입력을 고려하는 방법이며, 실행 하드웨어나 소프트웨어 환경과는 관계없이 알고리즘의 효율성을 평가할 수 있습니다.

### 알고리즘 분석에서 '좋다'의 의미

알고리즘 분석에서는 두 가지 측면을 고려할 수 있습니다. 

1. 시간 복잡도(time complexity): 알고리즘의 수행 시간 분석
2. 공간 복잡도(space complexity): 알고리즘이 필요로 하는 기억 공간의 양

우리가 알고리즘의 복잡도를 얘기할 땐 대개 시간 복잡도를 말합니다. 이유는 대개 알고리즘이 차지하는 공간보단 수행시간에 더 관심이 있기 때문입니다.

### 시간 복잡도(time complexity) 함수

시간 복잡도는 알고리즘의 절대적인 수행 시간을 나타내는 것이 아니라, 알고리즘을 이루고 있는 연산들이 몇 번 수행되는지 숫자로 표현합니다. 즉, 어떤 알고리즘이 수행하는 연산의 개수를 계산하여 두 알고리즘을 비교하는 것입니다.
- 연산의 종류: 덧셈, 곱셈과 같은 산술 연산, 대입 연산, 비교 연산, 이동 연산 등

이때 연산들의 수행횟수는 프로그램에 주어지는 입력의 개수 n에 따라 변하게 됩니다. 따라서 일반적으로 연산의 수행횟수는 고정된 숫자가 아니라, n에 대한 함수가 됩니다.

### 시간 복잡도 함수
연산의 수를 입력의 개수 n의 함수로 나타낸 것을 시간 복잡도 함수라고 하고, T(n)으로 표기합니다.

<b>양의 정수를 n을 n번 더하는 문제</b>

![Algorithm ABC](https://user-images.githubusercontent.com/76417259/185064818-c171177e-0122-457f-b70c-59a74aeab427.jpeg)

- 알고리즘 A: 간단하게 n*n을 계산
- 알고리즘 B: n을 n번 더함, 즉 n+n+...+n을 반복하는 셈
- 알고리즘 C: 1을 n*n번 더함

![표 1-3  알고리즘의 비교](https://user-images.githubusercontent.com/76417259/185064843-501b5bc7-99da-4fe6-a087-8029b5433e7c.jpeg)

- 사실 곱셈 연산이 덧셈 연산보다 시간이 더 걸리겠지만, 모든 연산이 동일한 시간이 걸린다고 가정하여 알고리즘을 비교합니다.
- 하나의 연산이 t만큼 시간이 걸린다고 가정하면, 알고리즘 A는 2t에 비례하는 시간이 필요하고, 알고리즘 B는 2nt의 시간이, 알고리즘 C는 2n^2t만큼의 시간이 걸립니다.

![그림 1-9  알고리즘의 시간 복잡도 함수](https://user-images.githubusercontent.com/76417259/185064855-b4e4b15f-d10e-431a-a881-2a3eb5f4606b.jpeg)

- n이 커질수록 알고리즘 간의 차이가 커지는 것을 확인할 수 있습니다.


## 빅오 표기법

일반적으로 입력 개수 n과 시간 복잡도 T(n)의 관계는 상당히 복잡할 가능성이 높습니다. (e.g. T(n) = n^2 + n + 1)
e.g. 하나의 루프 제어 문장에 비교 연산과 덧셈 연산, 대입 연산들이 마구 섞여있는 경우

그러나 중요한 것은 정확한 연산의 개수라기보다는 알고리즘의 일반적인 증가추세입니다.
자료의 개수가 많은 경우는 차수가 가장 큰 항이 영향을 크게 미치고, 다른 항들은 상대적으로 무시될 수 있기 때문입니다.

따라서 보통 시간복잡도 함수에서 차수가 가장 큰 항만을 고려하면 충분합니다.
(어차피 수행 시간이 서로 다른 연산, 곱셈과 덧셈 연산의 수행 시간이 같다고 가정한 것부터가 틀렸기 때문에, 정확한 비교가 의미 없을 수도 있습니다.)

<b>빅오 표기법</b>
시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법을 빅오 표기법이라고 합니다.

'알고리즘 A의 시간복잡도가 O(n)이다'라고 하면, 알고리즘이 n에 비례하는 수행시간을 가진다는 소리.
- 읽는 법: O(n)은 "빅오 of n"
- 빅오 표기법은 n의 값에 따른 함수의 상한값을 나타내는 방법

### 정의 1.2 빅오 표기법 (수학적 정의)
![정의 1 2 빅오 표기법](https://user-images.githubusercontent.com/76417259/185434816-911cc977-59de-4b20-a507-f3b96485cb53.jpeg)
![그림 1-11  빅오 표기법](https://user-images.githubusercontent.com/76417259/185435073-5b118039-331e-4114-8f00-f086170c3055.jpeg)

정의 파헤치기
- n이 매우 커지게 되면, f(n)의 값은 결국 g(n)보다 작거나 같게 됩니다.
- 따라서 이 정의는 g(n)이 f(n)의 상한값이라는 것을 의미합니다.
- 여기서 어떤 수 c와 n[0]에 대해 아무 의미가 없는 것에 주의: 이들이 아무 제한 없이 결정될 수 있다는 소리, 즉 위 부등식을 만족하는 c나 n[0]는 무수히 많을 수 있음
    - e.g. f(n)이 2n^2+3n+1이고, g(n)이 n^2이라면 |2n^2+3n+1|<=c|n^2|을 만족하는 c와 n[0] 쌍은 (6, 1), (5, 2), (4, 3), ... 등이 가능함
    - 따라서 위 정의에 의하여 2n^2+3n+1 = O(n^2)임

### 예제 1.1 빅오 표기법
- f(n) = 5 이면, O(1)
- f(n) = 2n+1 이면 O(n)
- f(n) = 3n^2+100 이면 O(n^2)
- f(n) = 5*2^n + 10n^2 + 100 이면 5(2^n)

즉, 간단하게 말해서 기본연산 횟수가 다항식으로 표현되었을 경우, 다항식의 최고차항만 남기고 다른 항들과 상수항들을 버리면 되는 셈이다.
- 다만 주의할 것은 logn은 없애버리면 안 된다. logn도 차수를 갖고 있기 때문이다.

<b>많이 쓰이는 빅오 표기법을 순서대로 표시</b>
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!)


## 빅오표기법 이외의 표기법

### 빅오 표기법의 문제점
빅오 표기법은 엄밀히 수학적 의미를 따지면, 상한을 표기한 것이므로 상한은 여러 개가 존재할 수 있습니다. (e.g. O(n)이라고 썼지만, 사실 O(n^2)으로 해도 수학적으론 틀리지 않음) 따라서 빅오 표기법은 최소 차수 함수로 표기되었을 경우만 의미가 있습니다.

이와 같은 문제점을 보완하기 위하여 빅오메가와 빅쎄타 표기법이 등장했습니다.

### 정의 1.3 빅오메가 표기법
![정의 1-3 빅오메가 표기법](https://user-images.githubusercontent.com/76417259/185439192-d317d19a-7d49-4d00-9052-9239a4a8df77.jpeg)

빅오메가(big omega)는 어떤 함수의 하한을 표시하는 방법입니다.

e.g. f(n)=2n+1 이면, n>1에 대하여 2n+1>=n이므로 f(n)=오메가(n)

### 정의 1.4 빅세타 표기법
![정의 1-4 빅세타 표기법](https://user-images.githubusercontent.com/76417259/185439194-d99a74cb-2a31-4d9d-8baf-56a2137d00e6.jpeg)

빅세타(big theta)는 동일한 함수를 상한(빅오 표기법)과 하한(빅오메가 표기법)으로 만들 수 있는 경우를 말합니다. 쉽게 말해서 빅오 표기법으로 찾은 값과 빅오메가 표기법으로 찾은 값이 같을 때, 이 경우를 빅세타 표기법으로 다시 한 번 정의할 수 있는 셈입니다.

![그림 1-13  빅오, 빅오메가, 빅세타 표기법의 비교](https://user-images.githubusercontent.com/76417259/185439201-4d2944bd-d0fe-4630-a0ee-089217c8b2f4.jpeg)

3개의 표기법 중 가장 정밀한 것은 빅세타이지만, 통상적으로 빅오 표기법(단, 최소차수를 상한으로 표시한다고 가정)을 많이 사용합니다.


## 최선, 평균, 최악의 경우

똑같은 알고리즘도 주어지는 입력의 집합에 따라 다른 수행 시간을 보낼 수 있습니다. 예를 들어 정렬 알고리즘에 거의 정렬된 자료집합을 준 것과 랜덤하게 배정된 자료집합을 주는 건 당연히 수행 시간이 다르겠죠.

따라서, 주어지는 자료집합에 따라 경우를 나누어 알고리즘의 효율성을 판단하기로 했습니다.

1. 최악의 경우(worst case): 알고리즘의 수행시간이 가장 오래 걸리는 경우, 알고리즘 시간 복잡도 척도로 가장 많이 쓰임, 입력 자료 집합을 알고리즘에 최대한 불리하도록 만들어 얼마만큼의 시간이 소모되는지 분석
    e.g. 비행기 관제 업무에 사용되는 알고리즘: 어떠한 입력에도 일정 시간 한도 내에서 반드시 계산을 끝마쳐야 함, 따라서 최악의 경우로 알고리즘 수행시간을 계산함
2. 최선의 경우(best case): 알고리즘의 수행시간이 가장 적은 경우, 별 의미가 없음
3. 평균적인 경우(average case): 알고리즘의 모든 입력을 고려하고 각 입력이 발생하는 확률을 고려하여 평균적인 수행시간, 가장 합리적으로 보이지만 구하기가 힘듦

### 프로그램 1.3 seq_search.c

```c
// 순차 탐색 알고리즘: 정렬되지 않은 배열을 순차적으로 탐색해 특정한 값을 찾음
int seq_search(int list[], int key)
{
    int i;
    for (i=0; i < n; i++)
        if (list[i] == key)
            return i;   // 탐색 성공하면 키 값의 인덱스 반환
    return -1;          // 탐색 실패하면 -1 반환
}
```

- 최선의 경우: 찾고자 하는 숫자가 배열의 맨 처음에 있음, 따라서 빅오 표기법으로 O(1)
- 최악의 경우: 찾고자 하는 숫자가 배열의 맨 뒤에 있음, 따라서 빅오 표기법으로 O(n)
- 평균적인 경우: 모든 숫자가 균일하게 탐색된다는 전제
    - 숫자마다 지가 걸렸을 때 비교 연산 수행 횟수가 있음, 그걸 다 더하고, 전체 숫자 개수로 나눠
    - 비교 연산 수행 횟수는 (1+2+...+n)/n=(n+1)/2
    - 따라서 빅오 표기법으로는 O(n)


## Quiz

1. 다음의 시간 복잡도 함수를 빅오 표기법으로 표시하라.

![1-3 Quiz](https://user-images.githubusercontent.com/76417259/185443520-471e387d-3888-43a3-a8fa-1a2004b92d59.jpeg)

(1) 9n^2+8n+1 => O(n^2)
(2) n!+2^n => O(n!)
(3) n^2
(4) 시그마 i 제곱은 (n)(n+1)(2n+1)/6 이므로 O(n^3)