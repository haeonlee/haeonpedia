문제 1. 
String 배열 A[ ]에 어떤 문자열 S가 저장되어 있는데, S의 빈칸(space ‘ ‘ 또는 tab ‘\t’)을 모두 ‘CSW’로 바꾸고자 한다.
다시 말하여 S의 모든 각 빈칸(single character)을 세 개의 character ‘CSW’로 바꾸는 것이다.

여기서,
(i) A에 저장된 문자열은 empty string일 수도 있으며,
(ii) 문자열에 빈칸이 없을 수도 있다.
(iii) 또한, 이 문제를 해결하기 위하여 추가 배열을 사용할 수 없는데, 다행히 배열 A의 크기는 충분히 커서 모든 빈 칸을 세 글자로 바꾸어 저장하는데 문제가 없다고 가정한다.
앞의 (i), (ii)의 경우에는 그냥 return하면 된다.

이 문제를 해결하기 위하여

1. 먼저 해결 알고리즘을 구상하여 이를 글로서 간략히 작성하여 보이시오. 단계별 또는 pseudocode로 알고리즘을 보일 수도 있지만, 이를 위하여 필요한 정의, 배경, 이렇게 하는 이유 등을 반드시 글로 먼저 작성해야 합니다. 그리고, 시간 복잡도를 반드시 보여야 합니다. 이를 위하여 입력 string S의 길이를 n이라고 가정합니다.

    (1) 필요한 정의, 배경, 이렇게 하는 이유 등을 반드시 글로 먼저 작성

    문제 1에서 가장 핵심적인 부분 두 개를 뽑자면
    (i) 각 빈칸(single character)를 세 개의 character로 바꾸어야 한다
    (ii) 문제를 해결하기 위하여 추가 배열을 사용할 수 없다
    이렇게 두 개일 것입니다.

    정리하자면, 
    하나의 배열 속에서 빈칸(single character)을 세 개의 character로 바꾸어야 한다는 말입니다.
    기존 문자열의 데이터를 손상시키지 않고(빈칸은 CSW로 바뀔 것이니 예외입니다.), 그대로 유지하면서 말이지요.

    그리하여 저는 character의 수를 확보하기 위해, 또 기존 데이터를 유지하기 위해 '복사'를 하기로 했습니다.

    함수 spaceTo0x20(char* A)는
    문자열을 역순으로 훑으며 빈칸(space 또는 \t)를 인식할 것입니다.
    그리고 인식을 했다면 해당 빈칸 후의 문자들을 2 character 뒤로 옮깁니다.
    그렇게 확보한 3 charater에 CSW 저장를 저장합니다.

    이를 문자열 index 0까지 계속합니다.
    그렇게 한다면, 문자열 내 모든 빈칸은 CSW로 변환되었을 것입니다.


    1) 문자열에 빈칸 없는 경우, 문자열이 empty string인 경우는 그냥 전달

    1) 추가 배열을 사용할 수 없기 때문에, 기존 배열 내에서 '복사' 기능을 사용해야 함
    : 따라서, 뒤에서부터 스페이스 또는 tab 문자를 인식 (해당 index 저장)
    : 인식이 됐다면 해당 문자로부터 뒤에 있는 문자들은 S[i+2] = S[i]; 이렇게 복사해서 뒤로 옮기고
    : 저장한 index부터 CSW 저장
    

2. 알고리즘을 구현한 C 함수 void spaceTo0x20(char* A)를 작성하여 보이시오. 문법 오류가 없어야 함은 물론 실행 가능해야 합니다.

***

시간 복잡도 O(n^2)