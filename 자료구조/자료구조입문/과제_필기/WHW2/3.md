원하는 객차 순서를 만든다는 말은 곧 "원하는 순서대로 객차를 pop 연산을 한다"는 것과 같습니다.

그렇다면 pop 연산이 원하는 순서대로 가능할 것인지는 어떻게 판단할 수 있을까요?

이를 이해하기 위해서 '객차를 pop 연산 하는 3가지 경우'를 구분할 필요가 있습니다.

(i) 원하는 객차가 string  S[]에서 stack으로 push 연산을 아직 안 한 경우: 원하는 객차가 stack의 top에 위치하게끔 push 연산을 한 뒤, pop 연산을 하면 됩니다. (이때, string S[]에서 원하는 객차 앞에 위치한 다른 객차들까지 stack 안으로 push하게 됩니다. 그리하여 아래 두 경우가 발생합니다.)

(ii) 원하는 객차가 stack의 top에 놓여져 있는 경우: pop 연산을 하면 됩니다.

(iii) 원하는 객차가 stack 안에 있지만, top에 놓여져 있지 않는 경우: 이러한 상황이 발생한다면, 곧 T[]가 요구하는 객차 순서를 만들 수 없다는 소립니다. stack은 후입선출(LIFO)이기 때문에 무슨 수를 써서도 stack의 top에 위치한 객차보다 먼저 나갈 수 없기 때문입니다. 따라서, 이 경우 “원하는 객차 순서를 얻을 수 없음”이라는 메시지를 띄우면 길동이의 고민은 해결될 것입니다.

그렇다면, string T[]가 원하는 객차 순서를 시뮬레이션 하다가 경우 (iii)를 만나면 “원하는 객차 순서를 얻을 수 없음”이라는 메시지를 띄우는 프로그램을 자세히 설명해 보겠습니다.

***

1) 객차 순서를 읽을 변수로 i, j=0으로 초기화: 1씩 증가시키며 S[]에서 객차를 push하고, T[]에서 원하는 객차 순서를 파악합니다.
2) S[]의 문자가 모두 소진될 때까지 아래 작업을 반복합니다.
- if T[j]의 문자 == top() (즉, stack의 top에 위치한 문자): pop(); j++;
- else: break 하고 push(S[i])를 다시 받아와야 함 // S[]에서 새로운 문자를 push
- 이때, stack이 empty stack이 된다면 S[]에서 push를 또 받아와야 함
3) S[]의 문자가 모두 소진했지만, 스택에 자료가 남아있으면 "원하는 객차 순서를 얻을 수 없음"을 출력

int main(){

    int i=0, j=0;

    for(i=0;i<n;i++){

        push(S[i]);

        while(1) {

            if(isEmpty()) break; // empty stack이면 break

            if(T[j]== top()){

                //s.top()이랑 j랑 맞으면 계속 꺼냄

                pop();

                j++;

            }

            else break; // 같지 않으면 break하여 push(S[i]) 하도록 유도
        }
    }

    if(!isEmpty()) printf("원하는 객차 순서를 얻을 수 없음");

}

-----

시간 복잡도 O(nlogn)