1ì°¨ ì‘ì„±ì¼: 2022. 09. 24. SAT
2ì°¨ ì‘ì„±ì¼: 

1. ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜
(5) ê³µê°„ ë³µì¡ë„(Space Complexity)

---

ì°¸ê³  ìë£Œ
* ê°•ì˜ <ìë£Œêµ¬ì¡°ì…ë¬¸>, ì„ì¢…ì„ êµìˆ˜ë‹˜, 2022í•™ë…„ë„ 2í•™ê¸° ì„œê°•ëŒ€í•™êµ
* ì±… <Cì–¸ì–´ë¡œ ì‰½ê²Œ í’€ì–´ ì“´ ìë£Œêµ¬ì¡°>, ì²œì¸êµ­ ì €

ê³µë¶€ë²•
* 1ì°¨ ì˜ˆìŠµ: ì±… <Cì–¸ì–´ë¡œ ì‰½ê²Œ í’€ì–´ ì“´ ìë£Œêµ¬ì¡°> (ë˜ëŠ” <í˜¼ì ê³µë¶€í•˜ëŠ” Cì–¸ì–´>)ë¥¼ ì½ìŠµë‹ˆë‹¤.
* 2ì°¨ ì˜ˆìŠµ: ê°•ì˜ <ìë£Œêµ¬ì¡°ì…ë¬¸> PPTë¥¼ ì½ìŠµë‹ˆë‹¤.
* 3ì°¨ ì˜ˆìŠµ: ìœ„ì—ì„œ í•™ìŠµí•œ ë‚´ìš©ì„ markdown ë¬¸ì„œë¡œ ì •ë¦¬í•©ë‹ˆë‹¤.
* ë³µìŠµ: ìˆ˜ì—…ì„ ë“£ê³  ë‚´ìš©ì„ ì •ë¦¬í•©ë‹ˆë‹¤.

---

# ê³µê°„ ë³µì¡ë„(Space Complexity)
- ê³µê°„ ë³µì¡ë„ëŠ” í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë  ë•Œê¹Œì§€ í•„ìš”í•œ ë©”ëª¨ë¦¬ì˜ ì–‘ì„ ë§í•©ë‹ˆë‹¤.

## ê³µê°„ ìš”êµ¬ ì‚¬í•­(Space Requirements)

### ê³ ì • ê³µê°„ ìš”êµ¬Fixed space requirements
- í”„ë¡œê·¸ë¨ì˜ ì…ì¶œë ¥ íšŸìˆ˜ë‚˜ ì‚¬ì´ì¦ˆì™€ëŠ” ìƒê´€ì´ ì—†ìŒ
- e.g. ëª…ë ¹ì–´(instruction space), ìƒìˆ˜(constants), ë‹¨ìˆœ ë³€ìˆ˜(simple variables), ê³ ì •ëœ êµ¬ì¡°ì²´ ë³€ìˆ˜(fixed-size structured variables)

### ê°€ë³€ ê³µê°„ ìš”êµ¬Variable space requirements
- í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘ì— ìš”êµ¬ë˜ëŠ” ê³µê°„ (Space needed by structured variables whose size depends on the particular instance, ğ¼, of the problem being solved.)
- í•¨ìˆ˜ê°€ ì¬ê·€ë¥¼ ì‚¬ìš©í•  ë•Œ, í•„ìš”í•œ ì¶”ê°€ ê³µê°„: ë°˜í™˜ ì£¼ì†Œ(return address) ë° ì¸ìˆ˜(arguments)ë¥¼ ìœ„í•œ ê³µê°„
- ìš°ë¦¬ëŠ” ë³´í†µ í”„ë¡œê·¸ë¨ì˜ ê³µê°„ ë³µì¡ë„ë¥¼ ìƒê°í•  ë•Œ, variable space requirementsì— ë”ìš± ì‹ ê²½ì„ ì”€

### S(P) = c + Sp(I)

(1) Sp(I): íŠ¹ì • ì¸ìŠ¤í„´ìŠ¤ Iì™€ ì—°ê´€(e.g. íšŸìˆ˜, ì‚¬ì´ì¦ˆ, ì…ì¶œë ¥ ê°’)ë˜ëŠ” ê°€ë³€ ê³µê°„ì„ í‘œê¸°í•œ ê²ƒ
(2) c: the fixed space requirements
(3) If ğ‘› is the only characteristic, we use ğ‘†p(ğ‘›) to represent ğ‘†p(ğ¼).

### Example 01: fixed sized input

```c
// Sabc(I) = 0
// ì™œëƒí•˜ë©´, ì•„ë˜ ì½”ë“œëŠ” ì˜¤ì§ fixed space requirementsë¥¼ ê°–ê³  ìˆì–´ì„œ

float abc(float a, float b, float c) {
    return a+b+b*c + (a+b-c)/(a+b) + 4.00;
}
```

### Example 02: adding number

```c
// Ssum(I) = 0
// ì™œëƒí•˜ë©´, L[]ì€ ë°°ì—´ Lì˜ ì²« ë²ˆì§¸ ìš”ì†Œì˜ ì£¼ì†Œì¼ ë¿
// ì£¼ì†Œë¥¼ ì „ë‹¬(call by reference)í•˜ëŠ” ê±´ ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ ê³µê°„ì„ í•„ìš”ë¡œ í•˜ì§€ ì•ŠìŒ

int sum(int L[], int n) {
    int i, tsum = 0;
    for (i=0; i<n; i++)
        tsum += L[i];
    return tsum;
}
```

```c
// Sin and sum(I) = n
// ì™œëƒí•˜ë©´, the size of L depends on n.

int in_and_sum(int n){                  // ì…ë ¥í•  ìˆ«ì nê°œ ì…ë ¥
    int i, L*, tsum = 0;
    MALLOC(L, int*, n*sizeof(int));     // ë°°ì—´ Lì„ nê°œë§Œí¼ ë™ì  í• ë‹¹
    for (i=0; i<n; i++)
        scanf("%d", &L[i]);             // ë°ì´í„° nê°œë¥¼ ìˆ˜ê¸°ë¡œ ì…ë ¥
    for (i=0; i<n; i++)
        tsum += L[i];                   // wrong
    return tsum;                        // function
    // L[0:n-1] is dangled
    // free(L) is required
}

/* MALLOC ë§¤í¬ë¡œ í•¨ìˆ˜ ì •ì˜

#define MALLOC(ptr, type, size)            \
if (!((ptr)=(type)malloc(size))) {         \
   fprintf(stderr, "Insufficient memory"); \
   exit(EXIT_FAILURE);            }

*/
```

### Example 03: sum by recursion

```c
// 32 bit environment ê¸°ì¤€
// Srsum(n) = 12(n+1)

int rsum(int L[], int n) {
    if ( n > 0 )
        return
            rsum(L, n-1) + L[n-1];
    return 0;
}
```

- Arguments size for each call
(1) return address(í•¨ìˆ˜ íšŒê·€ ì£¼ì†Œ) : 4 bytes
(2) pointer constant L[] : 4 bytes
(3) integer n : 4 bytes
-> total : 12 bytes/call

- Recursive call = n + 1
ì „ì²´ ë‹¤ ëŒê¸° ìœ„í•´ì„œëŠ” (n+1)ë²ˆ íšŒì „í•¨

